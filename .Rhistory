geom_point(mapping = aes_string(x, y), alpha = self$dense)
},
dta = NULL,
eps = NULL,
pts = NULL,
clusters = NULL,
dense = NULL,
point_def = NULL,
results = NULL
),
private = list(
expand = function(point){
self$clusters[point] = private$currentPoint
self$dense[point] = private$get_density(private$neighbors_dist)
self$point_def[point] = "Core Point"
j = 1L
while(j > 0L) {
nextPoint = private$neighbors_id[j]
if(self$clusters[nextPoint] == -1L) {
self$clusters[nextPoint] = private$currentPoint
neighbors = private$get_neighbors(dta, dta[nextPoint, ])
self$dense[nextPoint] = private$get_density(neighbors$dist)
} else if(self$clusters[nextPoint] == 0L) {
self$clusters[nextPoint] = private$currentPoint
nextNeighbors = private$get_neighbors(dta, dta[nextPoint, ])
if(sum(nextNeighbors$dist) >= min(self$pts)) {
self$dense[nextPoint] = private$get_density(nextNeighbors$dist)
self$point_def[nextPoint] = "Core Point"
new_neighbours = setdiff(nextNeighbors$id, private$neighbors_id)
private$neighbors_id = c(private$neighbors_id,
nextNeighbors$id)
} else {
private$border_n = append(private$border_n,
list(c("id" = nextPoint, nextNeighbors$id))
)
private$border_id = c(private$border_id, nextPoint)
}
}
j = ifelse(length(private$neighbors_id) <= j, 0L, j + 1L)
}
},
get_neighbors = function(dta, query){
n_list = dbscan::frNN(dta, max(self$eps), query)
dist = (max(self$eps) - n_list$dist[[1]][-1]) / (max(self$eps) - min(self$eps))
dist[dist > 1L] = 1
list("id" = n_list$id[[1L]][-1L],
"dist" = dist
)
},
get_density = function(n_dist){
if(sum(n_dist) > max(self$pts)) return(1)
if(length(self$pts) == 1L) return(sum(n_dist) / self$pts)
(sum(n_dist) - min(self$pts)) / (max(self$pts) - min(self$pts))
},
get_border_density = function(b_vec){
fcores = setdiff(b_vec, private$border_id)
c("id" = b_vec["id"],
"dense" = min(self$dense[fcores]))
},
return_probs = function(clusters, dense){
ids = sort(unique(clusters))
prob_per_cl = lapply(ids, function(x){
vec = rep(0, length(clusters))
vec[clusters == x] = dense[clusters == x]
vec
})
prob_df = do.call(cbind.data.frame, prob_per_cl)
colnames(prob_df) = ids
prob_df[, 1] = 1 - abs(apply(prob_df[, -1], 1, sum))
data.table(prob_df)
},
predict_observation = function(x) {
x = matrix(x, nrow = 1)
neigh = private$get_neighbors(self$dta, query = x)
n_clusters = self$clusters[neigh$id]
# case 1: point is noise if there is no core point around
if(sum(neigh$dist) < min(self$pts)) {
if(!any(self$point_def[neigh$id] == "Core Point")){
return(data.table("cluster" = -1L, "dense" = 1L))
}
}
# Delete noise around pt
if(any(n_clusters == -1L)) {
neigh$id = neigh$id[n_clusters != -1]
neigh$dist = neigh$dist[n_clusters != -1]
n_clusters = n_clusters[n_clusters != -1]
}
#Should be length 1
cluster = unique(self$clusters[neigh$id])
if(length(cluster) > 1L){
# Point in neighborhood are assigned to multiple clusters assigned.
# Closest pt cluster assignment is used as reference.
cluster = n_clusters[which.min(neigh$dist)]
neigh$id = neigh$id[n_clusters == cluster]
neigh$dist = neigh$dist[n_clusters == cluster]
}
# case 2: new core pt
if(sum(neigh$dist) >= min(self$pts)){
return(
data.table("cluster" = cluster,
"dense" = private$get_density(neigh$dist)))
}
# Border Point: neighbordist < minpts but core point around
# Density is the minimal dense of a point around
idx = which.min(self$dense[neigh$id])
id = neigh$id[idx]
data.table("cluster" = self$clusters[id],
"dense" = self$dense[id])
},
currentPoint = NULL,
neighbors_id = NULL,
neighbors_dist = NULL,
border_id = NULL,
border_n = NULL
)
)
cl = Fuzzy_DBSCAN$new(dta, eps, pts)
a = cl$predict(p_dta)
a
View(a)
cl$plot()
cl$plot("x", "y")
?iml::Predictor
?dbscan
?dbscan::dbscan
dbscan::frNN(iris, 0.2, iris)
?dbscan::dbscan
library(checkmate)
roxygen2::roxygenise()
R6Class
devtools::document()
library(devtools)
use_testthat()
use_roxygen_md()
document()
document()
check()
check()
check()
check()
library(R6)
check()
check()
check()
check()
check()
check()
dta = multishapes[, 1:2]
library(factoextra)
dta = multishapes[, 1:2]
eps = c(0, 0.2)
pts = c(3, 15)
cl = FuzzyDBScan$new(dta, eps, pts)
# Plot DBScan for x and y
library(ggplot2)
cl$plot("x", "y")
# produce test data
x <- seq(min(dta$x), max(dta$x), length.out = 50)
y <- seq(min(dta$y), max(dta$y), length.out = 50)
p_dta = expand.grid(x = x, y = y)
# predict on test data and plot results
p = cl$predict(p_dta)
colnames(self$dta)
#' p = cl$predict(p_dta)
#' ggplot(p, aes(x = p_dta[, 1], y = p_dta[, 2], colour = as.factor(cluster))) +
#'   geom_point(alpha = a$dense)
#' @import R6
#' @import checkmate
#' @importFrom data.table data.table
#' @importFrom dbscan frNN
#' @import ggplot2
#' @name Fuzzy_DBScan
#' @export
FuzzyDBScan = R6Class("FuzzyDBScan",
public = list(
#' @description Create a FuzzyDBScan object. Apply the
#'  fuzzy DBScan algorithm given the data `dta`, the
#'  range of the radius `eps` and the range of the
#'  Points `pts`.
#' @param dta [data.frame] | [matrix]\cr
#'  The data to be clustered by the algorithm. Allowed
#'  are only [numeric] columns.
#' @param eps [numeric]\cr
#'  The size (radius) of the epsilon neighborhood.
#'  If  the radius contains 2 numbers, the fuzzy cores
#'  are calculated between the minimum and the maximum
#'  radius.
#'  If epsilon is a single number, the algorithm
#'  looses the fuzzy core property. If the length of
#'  `pts` is also 1L, the algorithm equals to non-fuzzy
#'  DBScan.
#' @param pts [numeric]\cr
#' number of maximum and minimum points required in the
#' `eps`  neighborhood for core points (excluding the
#' point itself). If the length ot the argument is 1,
#' the algorithm looses its fuzzy border property. If
#' the length of `eps` is also 1L, the algorithm equals
#' to non-fuzzy DBScan.
initialize = function(dta, eps, pts){
if(is.matrix(dta)) dta = data.table(dta)
assert_data_frame(dta, types = "numeric",
min.rows = 2L, min.cols = 1L)
assert_numeric(eps, lower = 0L, any.missing = FALSE,
min.len = 1L, max.len = 2L)
assert_integerish(pts, lower = 1L, upper = nrow(dta),
any.missing = FALSE, min.len = 1L,
max.len = 2L)
self$dta = dta
self$eps = eps
self$pts = pts
private$currentPoint = 0L
private$border_n = list()
self$clusters = rep(0L, times = nrow(dta))
self$dense = rep(0L, times = nrow(dta))
self$point_def = rep(NA, times = nrow(dta))
for(i in 1L:nrow(self$dta)) {
if(self$clusters[i] != 0L) next
neighbors = private$get_neighbors(dta, dta[i, ])
private$neighbors_dist = neighbors$dist
if(sum(private$neighbors_dist) < min(pts)) {
self$clusters[i] = -1L
self$dense[i] = 1L
} else {
private$neighbors_id = neighbors$id
private$currentPoint = private$currentPoint + 1L
private$expand(i)
}
}
self$point_def[self$clusters == -1L] = "Noise"
self$point_def[private$border_id] = "Border Point"
b_densities = lapply(private$border_n, private$get_border_density)
lapply(b_densities, function(x) self$dense[x[1]] = x[2])
self$results = private$return_probs(self$clusters, self$dense)
},
#' @description Predict new data with the initialized
#' algorithm.
#' @param new_data [data.frame] | [matrix]\cr
#'  The data to be predicted by the algorithm. Allowed
#'  are only [numeric] columns which should match to
#'  `self$dta`.
#' @param cmatrix [logical]\cr
#'  Indicating whether the assigned cluster should be
#'  returned in form of a matrix where each column
#'  indicates for the probability of the new data to
#'  belong to a respective cluster. The object will have
#'  the same shape as the `results` field. If set to
#'  `FALSE` the shape of the returned assigned clusters
#'  is a two-column [data.table] with one column
#'  indicating the assigned cluster and the second
#'  column indicating the respective probability of
#'  the new data.
predict = function(new_data, cmatrix = TRUE){
if(is.matrix(dta)) dta = data.table(dta)
assert_data_frame(dta, ncols = ncol(self$dta),
types = c("numeric", "integerish"),
any.missing = FALSE, min.rows = 1L)
assert_logical(cmatrix, any.missing = FALSE, len = 1L)
result = apply(new_data, 1, private$predict_observation)
cluster_df = rbindlist(result)
if(!cmatrix) return(cluster_df)
private$return_probs(cluster_df$cluster, cluster_df$dense)
},
#' @description Plot clusters and soft labels on two
#'  features.
#' @param x [character]\cr
#' Feature to plot on the x-axis.
#' @param y [character]\cr
#' Feature to plot on the y-axis.
plot= function(x, y){
assert_character(x, any.missing = FALSE, len = 1L)
assert_character(y, any.missing = FALSE, len = 1L)
ggplot(data = self$dta, aes(colour = as.factor(self$clusters))) +
geom_point(mapping = aes_string(x, y), alpha = self$dense)
},
#' @field dta [data.frame] | [matrix]\cr
#'  The data to be clustered by the algorithm. Allowed
#'  are only [numeric] columns.
dta = NULL,
#' @field eps [numeric]\cr
#'  The size (radius) of the epsilon neighborhood.
#'  If  the radius contains 2 numbers, the fuzzy cores
#'  are calculated between the minimum and the maximum
#'  radius.
#'  If epsilon is a single number, the algorithm
#'  looses the fuzzy core property. If the length of
#'  `pts` is also 1L, the algorithm equals to non-fuzzy
#'  DBScan.
eps = NULL,
#' @field pts [numeric]\cr
#'  number of maximum and minimum points required in the
#'  `eps`  neighborhood for core points (excluding the
#'  point itself). If the length ot the argument is 1,
#'  the algorithm looses its fuzzy border property. If
#'  the length of `eps` is also 1L, the algorithm equals
#'  to non-fuzzy DBScan.
pts = NULL,
#' @field clusters [factor]\cr
#'  Contains the assigned clusters per observation in
#'  the same order as in `dta`.
clusters = NULL,
#' @field dense [numeric]\cr
#'  Contains the assigned density estimates per
#'  observation in the same order as in `dta`.
dense = NULL,
#' @field point_def [character]\cr
#'  Contains the assigned definition estimates per
#'  observation in the same order as in `dta`. Possible
#'  are "Core Point", "Border Point" and "Noise".
point_def = NULL,
#' @field results [data.table]\cr
#'  A table where each column indicates for the
#'  probability of the new data to belong to a
#'  respective cluster.
results = NULL
),
private = list(
expand = function(point){
self$clusters[point] = private$currentPoint
self$dense[point] = private$get_density(private$neighbors_dist)
self$point_def[point] = "Core Point"
j = 1L
while(j > 0L) {
nextPoint = private$neighbors_id[j]
if(self$clusters[nextPoint] == -1L) {
self$clusters[nextPoint] = private$currentPoint
neighbors = private$get_neighbors(dta, dta[nextPoint, ])
self$dense[nextPoint] = private$get_density(neighbors$dist)
} else if(self$clusters[nextPoint] == 0L) {
self$clusters[nextPoint] = private$currentPoint
nextNeighbors = private$get_neighbors(dta, dta[nextPoint, ])
if(sum(nextNeighbors$dist) >= min(self$pts)) {
self$dense[nextPoint] = private$get_density(nextNeighbors$dist)
self$point_def[nextPoint] = "Core Point"
new_neighbours = setdiff(nextNeighbors$id, private$neighbors_id)
private$neighbors_id = c(private$neighbors_id,
nextNeighbors$id)
} else {
private$border_n = append(private$border_n,
list(c("id" = nextPoint, nextNeighbors$id))
)
private$border_id = c(private$border_id, nextPoint)
}
}
j = ifelse(length(private$neighbors_id) <= j, 0L, j + 1L)
}
},
get_neighbors = function(dta, query){
n_list = frNN(dta, max(self$eps), query)
dist = (max(self$eps) - n_list$dist[[1]][-1]) / (max(self$eps) - min(self$eps))
dist[dist > 1L] = 1
list("id" = n_list$id[[1L]][-1L],
"dist" = dist
)
},
get_density = function(n_dist){
if(sum(n_dist) > max(self$pts)) return(1)
if(length(self$pts) == 1L) return(sum(n_dist) / self$pts)
(sum(n_dist) - min(self$pts)) / (max(self$pts) - min(self$pts))
},
get_border_density = function(b_vec){
fcores = setdiff(b_vec, private$border_id)
c("id" = b_vec["id"],
"dense" = min(self$dense[fcores]))
},
return_probs = function(clusters, dense){
ids = sort(unique(clusters))
prob_per_cl = lapply(ids, function(x){
vec = rep(0, length(clusters))
vec[clusters == x] = dense[clusters == x]
vec
})
prob_df = do.call(cbind.data.frame, prob_per_cl)
colnames(prob_df) = ids
prob_df[, 1] = 1 - abs(apply(prob_df[, -1], 1, sum))
data.table(prob_df)
},
predict_observation = function(x) {
x = matrix(x, nrow = 1)
neigh = private$get_neighbors(self$dta, query = x)
n_clusters = self$clusters[neigh$id]
# case 1: point is noise if there is no core point around
if(sum(neigh$dist) < min(self$pts)) {
if(!any(self$point_def[neigh$id] == "Core Point")){
return(data.table("cluster" = -1L, "dense" = 1L))
}
}
# Delete noise around pt
if(any(n_clusters == -1L)) {
neigh$id = neigh$id[n_clusters != -1]
neigh$dist = neigh$dist[n_clusters != -1]
n_clusters = n_clusters[n_clusters != -1]
}
#Should be length 1
cluster = unique(self$clusters[neigh$id])
if(length(cluster) > 1L){
# Point in neighborhood are assigned to multiple clusters assigned.
# Closest pt cluster assignment is used as reference.
cluster = n_clusters[which.min(neigh$dist)]
neigh$id = neigh$id[n_clusters == cluster]
neigh$dist = neigh$dist[n_clusters == cluster]
}
# case 2: new core pt
if(sum(neigh$dist) >= min(self$pts)){
return(
data.table("cluster" = cluster,
"dense" = private$get_density(neigh$dist)))
}
# Border Point: neighbordist < minpts but core point around
# Density is the minimal dense of a point around
idx = which.min(self$dense[neigh$id])
id = neigh$id[idx]
data.table("cluster" = self$clusters[id],
"dense" = self$dense[id])
},
currentPoint = NULL,
neighbors_id = NULL,
neighbors_dist = NULL,
border_id = NULL,
border_n = NULL
)
)
cl = FuzzyDBScan$new(dta, eps, pts)
# Plot DBScan for x and y
library(ggplot2)
cl$plot("x", "y")
# produce test data
x <- seq(min(dta$x), max(dta$x), length.out = 50)
y <- seq(min(dta$y), max(dta$y), length.out = 50)
p_dta = expand.grid(x = x, y = y)
# predict on test data and plot results
p = cl$predict(p_dta)
library(data.table)
p = cl$predict(p_dta)
ggplot(p, aes(x = p_dta[, 1], y = p_dta[, 2], colour = as.factor(cluster))) +
geom_point(alpha = a$dense)
ggplot(p, aes(x = p_dta[, 1], y = p_dta[, 2], colour = as.factor(cluster))) +
geom_point(alpha = p$dense)
p
p = cl$predict(p_dta, FALSE)
ggplot(p, aes(x = p_dta[, 1], y = p_dta[, 2], colour = as.factor(cluster))) +
geom_point(alpha = p$dense)
check()
check()
check()
library(testthat)
runif(2, -1, -2)
?runif
runif(2, -2, 1)
runif(2, -2, -1)
letters(2)
letters()
letters
letters[1:2]
err_args = list(
"dta_factors" = c("dta" = iris, "eps" = rnorm(2), "pts" = c(3, 4)),
"dta_empty" = c("dta" = data.frame(), "eps" = runif(2), "pts" = c(3, 4)),
"dta_class" = c("dta" = rnorm(100), "eps" = runif(2), "pts" = c(3, 4)),
"eps_sm0" = c("dta" = matrix(rnorm(100), ncol = 4), "eps" = runif(2, -2, -1), "pts" = c(3, 4)),
"eps_chr" = c("dta" = matrix(rnorm(100), ncol = 4), "eps" = letters[1:2], "pts" = c(3, 4)),
"eps_len" = c("dta" = matrix(rnorm(100), ncol = 4), "eps" = runif(3), "pts" = c(3, 4)),
"eps_NA" = c("dta" = matrix(rnorm(100), ncol = 4), "eps" = NA, "pts" = c(3, 4)),
"pts_sm0" = c("dta" = matrix(rnorm(100), ncol = 4), "eps" = runif(2), "pts" = c(-3, 4)),
"pts_double" = c("dta" = matrix(rnorm(100), ncol = 4), "eps" = runif(2), "pts" = runif(2)),
"pts_len" = c("dta" = matrix(rnorm(100), ncol = 4), "eps" = runif(2), "pts" = 3:5),
"pts_NA" = c("dta" = matrix(rnorm(100), ncol = 4), "eps" = runif(2), "pts" = NA)
)
lapply(err_args, function(x) {
expect_error(
do.call(FuzzyDBScan$new, x)
)
})
data = multishapes[, 1:2]
eps = 0.15
pts = 5
fdbscan = FuzzyDBScan$new(data, eps, pts)
check()
eps = 0.15
pts = 5
data = multishapes[, 1:2]
fdbscan = FuzzyDBScan$new(data, eps, pts)
fdbscan
fdbscan = FuzzyDBScan$new(data, eps, pts)$clusters
fdbscan
dbscan = dbscan::dbscan(data, eps, pts)
dbscan
dbscan$cluster
dbscan = dbscan::dbscan(data, eps, pts)$cluster
dbscan[dbscan == 0L] = -1L
dbscan
fdbscan == dbscan
fdbscan
dbscan
fdbscan = FuzzyDBScan$new(data, eps, pts)
test_character(fdbscan$point_def, n.chars = nrow(data))
fdbscan$point_def
nrow(data)
fdbscan$point_def
fdbscan$dense
test_numeric(fdbscan$dense, len = nrow(data))
test_character(fdbscan$point_def, len = nrow(data))
test_integerish(fdbscan$clusters, len = nrow(data))
test_set_equal(self$dta, data)
test_set_equal(fdbscan$dta, data)
eps = c(0.15, 0)
pts = c(4, 8)
data = factoextra::multishapes[, 1:2]
fdbscan = FuzzyDBScan$new(data, eps, pts)
test_character(fdbscan$point_def, len = nrow(data))
test_numeric(fdbscan$dense, len = nrow(data))
test_integerish(fdbscan$clusters, len = nrow(data))
load_all()
install()
